C51 COMPILER V9.01   KS_CPU                                                                06/05/2012 15:05:52 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE KS_CPU
OBJECT MODULE PLACED IN ks_cpu.obj
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE uCosii\ks_cpu.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\ks_cpu.lst) OBJECT(
                    -ks_cpu.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                               KingSky
   4          *                                          实时操作系统内核
   5          *
   6          *                                       (c) Copyright 2011, 庄桐泉
   7          *                                          All Rights Reserved
   8          *
   9          * File         : ks_cpu.c
  10          ********************************************************************************************************* 
             -*/
  11          #include "KingSky.h"
  12          
  13          
  14          
  15           KS_STACK * ks_stack_init(THREAD_ADDR thread_addr,void *p_arg,KS_STACK *stk1) reentrant
  16          {
  17   1          KS_STACK *stk;
  18   1          p_arg = p_arg; 
  19   1          stk    = stk1;                              //用户堆栈最低有效地址
  20   1          *stk++ = 15;                                //用户堆栈长度
  21   1          *stk++ = (uint16)thread_addr & 0xFF;               //任务地址低8位
  22   1          *stk++ = (uint16)thread_addr >> 8;                 //任务地址高8位    
  23   1          *stk++ = 0x0A;                              //ACC
  24   1          *stk++ = 0x0B;                              //B
  25   1          *stk++ = 0x00;                              //DPH
  26   1          *stk++ = 0x00;                              //DPL
  27   1          *stk++ = 0x00;                              //PSW
  28   1          *stk++ = 0x00;                              //R0
  29   1          
  30   1              //R3、R2、R1用于传递任务参数ppdata，其中R3代表存储器类型，R2为高字节偏移，R1为低字节位移。
  31   1              //通过分析KEIL汇编，了解到任务的void *ppdata参数恰好是用R3、R2、R1传递，不是通过虚拟堆栈。
  32   1          *stk++ = (uint16)p_arg & 0xFF;             //R1
  33   1          *stk++ = (uint16)p_arg >> 8;               //R2
  34   1          *stk++ = 0x01;                              //R3  因为我用的全是XDATA，所以存储器类型固定为1，见C51.PD
             -F第178页说明。
  35   1      
  36   1          *stk++ = 0x04;                              //R4
  37   1          *stk++ = 0x05;                              //R5
  38   1          *stk++ = 0x06;                              //R6
  39   1          *stk++ = 0x07;                              //R7
  40   1                                                      //不用保存SP，任务切换时根据用户堆栈长度计算得出。    
  41   1          *stk++ = (uint16) (stk1+MaxStkSize) >> 8;   //?C_XBP 仿真堆栈指针高8位
  42   1          *stk++ = (uint16) (stk1+MaxStkSize) & 0xFF; //?C_XBP 仿真堆栈指针低8位
  43   1              
  44   1          return ((void *)stk1);
  45   1      
  46   1      }
  47          
  48          void UserTickTimer(void) reentrant
  49          {
  50   1      /*      TH0=0x70;               //普通51定时器方式1，必须在发生中断时，重新赋值并再次启动计时
  51   1          TL0=0;              //Tick=50次/秒(即0.02秒/次)，晶振22.1184M          */
  52   1              TH0=0xB8;               //普通51定时器方式1，必须在发生中断时，重新赋值并再次启动计时
C51 COMPILER V9.01   KS_CPU                                                                06/05/2012 15:05:52 PAGE 2   

  53   1          TL0=0;              //Tick=50次/秒(即0.02秒/次)，晶振11.0592M
  54   1      //      ET0=1;              //允许T0中断
  55   1          TR0=1;
  56   1      }
  57          
  58          /* 
  59            ucOS-II系统时钟中断处理程序
  60          */
  61            sbit LED2 = P2^3;
  62          
  63          
  64           
  65          
  66          void ks_tick_isr(void) interrupt 1
  67          {
  68   1              LED2 = ~LED2;
  69   1          ks_int_enter();                                     // Must be called first at every hardware interrupt entry point 
  70   1          UserTickTimer();                            // User functions can be called here.
  71   1              ks_time_tick();                                 // Must be called during tick isr
  72   1              ks_int_exit();                                  // Must be called finally at every hardware interupt exit point 
  73   1      }
  74          
  75          /*
  76            设置硬件寄存器的初始值。
  77            初始化定时器0,作为ucOS-II的系统时钟。
  78            还有其他的与硬件相关的初始化也可以放在这里。
  79          */
  80          
  81          void InitHardware(void) reentrant
  82          {   
  83   1          TMOD = 0x01;   //定时器0：模式1(16位定时器)，仅受TR0控制；定时器1：波特率发生器
  84   1          TMOD=TMOD&0xF0;
  85   1          TMOD=TMOD|0x01;    //模式1(16位定时器)，仅受TR0控制
  86   1      //      TMOD = 0x11;
  87   1         /* TH0  = 0x70;   //定义Tick=50次/秒(即0.02秒/次),TH,TL值与CPU的频率有关(22.1184M)
  88   1          TL0  = 0x00;   //OS_CPU_C.C中定时器中断响应也要设置，OS_CFG.H中OS_TICKS_PER_SEC也有关系             */
  89   1          TH0=0xB8;                   //普通51定时器方式1，必须在发生中断时，重新赋值并再次启动计时
  90   1          TL0=0;              //Tick=50次/秒(即0.02秒/次)，晶振11.0592M
  91   1          //ET0  = 1;    //允许T0中断(在第一个任务开始执行时才开时钟中断,否则万一中断系统进入不可知状态)
  92   1          TR0  = 1;
  93   1              ET0=1;  //开时钟节拍中断
  94   1      //      EA = 1;
  95   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    689    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
